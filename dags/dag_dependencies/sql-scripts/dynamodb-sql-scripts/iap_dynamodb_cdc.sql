MERGE INTO {{ params.env }}.core.iap USING (
    SELECT 
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: PK: S::VARCHAR(16777216) AS pk,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: SK: S::VARCHAR(16777216) AS sk,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: UserID: S::VARCHAR(16777216) AS userid,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: BundleID: S::VARCHAR(16777216) AS bundleid,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: ProductID: S::VARCHAR(16777216) AS productid,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: ProductType: S::VARCHAR(16777216) AS producttype,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: Status: S::VARCHAR(16777216) AS status,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: DeveloperPayload: S::VARCHAR(16777216)
            AS developerpayload,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: AutoRenewing: BOOL::BOOLEAN AS autorenewing,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: CalculatedExpireDateMS: N::TIMESTAMP
            AS calculatedexpiredate,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: CancellationDateMS: N::TIMESTAMP AS cancellationdate,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: ItemTTL: N::TIMESTAMP AS itemttl,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: CancellationReason: S::VARCHAR(16777216)
            AS cancellationreason,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: OriginalPurchaseDateMS: N::TIMESTAMP
            AS originalpurchasedate,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: OriginalTransactionID: S::VARCHAR(16777216)
            AS originaltransactionid,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: Vendor: S::VARCHAR(16777216) AS vendor,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: CountryCode: S::VARCHAR(16777216) AS countrycode,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: OrderID: S::VARCHAR(16777216) AS orderid,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: PackageName: S::VARCHAR(16777216) AS packagename,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: Environment: S::VARCHAR(16777216) AS environment,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: ExpirationIntent: S::VARCHAR(16777216)
            AS expirationintent,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: ExpiresDateMS: N::TIMESTAMP AS expiresdate,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: ExpiryTimeMillis: N::TIMESTAMP AS expirytime,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: IsInBillingRetryPeriod: S::VARCHAR(16777216)
            AS isinbillingretryperiod,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: IsInIntroOfferPeriod: S::VARCHAR(16777216)
            AS isinintroofferperiod,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: IsTrialPeriod: S::VARCHAR(16777216) AS istrialperiod,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: LinkedPurchaseToken: S::VARCHAR(16777216)
            AS linkedpurchasetoken,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: Quantity: S::VARCHAR(16777216) AS quantity,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: TransactionID: S::VARCHAR(16777216) AS transactionid,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: PurchaseState: N::NUMBER AS purchasestate,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: PurchaseStartTimeMillis: N::timestamp
            AS purchasestarttime,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: PurchaseToken: S::VARCHAR(16777216) AS purchasetoken,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: PurchaseType: N::NUMBER AS purchasetype,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: VoidedReason: N::NUMBER AS voidedreason,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: VoidedSource: N::NUMBER AS voidedsource,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: VoidedTimeMillis: N::NUMBER AS voidedtime,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: PaymentState: N::NUMBER AS paymentstate,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: CancelReason: N::NUMBER AS cancelreason,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: CancelSurveyResultCancelSurveyReason: N::NUMBER
            AS cancelsurveyresultcancelsurveyreason,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: CancelSurveyResultUserInputcancelreason: N::NUMBER
            AS cancelsurveyresultuserinputcancelreason,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: ConsumptionState: N::NUMBER AS consumptionstate,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: UserCancellationTimeMillis: N::TIMESTAMP
            AS usercancellationtime,
        PARSE_JSON("payload.record_json"): eventName::VARCHAR(16777216) AS eventname,
        PARSE_JSON("payload.record_json"): dynamodb: NewImage: CreatedAt: N::TIMESTAMP AS createdat,
        PARSE_JSON("payload.record_json") :dynamodb :ApproximateCreationDateTime::TIMESTAMP
             AS approximate_creation_date_time,
        inserted_timestamp,
        s3_file_path
    FROM prod.party_planner_realtime.streamrecord
    WHERE (inserted_timestamp > '{{ prev_data_interval_end_success or data_interval_start }}')
        AND (inserted_timestamp <= '{{ data_interval_end }}')
        AND (UPPER(INSTANCE_ID) LIKE '%%IAP%%')
        AND (pk IS NOT NULL)
    QUALIFY ROW_NUMBER() OVER (PARTITION BY pk, sk ORDER BY approximate_creation_date_time DESC) = 1
) AS ppr_source ON (iap.pk = ppr_source.pk) AND (iap.sk = ppr_source.sk)
WHEN MATCHED
    AND (UPPER(ppr_source.eventname) IN ('MODIFY', 'REMOVE', 'INSERT'))
    AND (ppr_source.approximate_creation_date_time > iap.event_creation_timestamp)
THEN UPDATE SET
    --dyanmodb events timestamp condition is needed for the back-filling
    --    usecase ie when the pk is changed in the future dag instances dont overwrite in the backfill process
    sk = ppr_source.sk,
    userid = ppr_source.userid,
    bundleid = ppr_source.bundleid,
    productid = ppr_source.productid,
    producttype = ppr_source.producttype,
    status = ppr_source.status,
    developerpayload = ppr_source.developerpayload,
    autorenewing = ppr_source.autorenewing,
    calculatedexpiredate = ppr_source.calculatedexpiredate,
    cancellationdate = ppr_source.cancellationdate,
    itemttl = ppr_source.itemttl,
    cancellationreason = ppr_source.cancellationreason,
    originalpurchasedate = ppr_source.originalpurchasedate,
    originaltransactionid = ppr_source.originaltransactionid,
    vendor = ppr_source.vendor,
    countrycode = ppr_source.countrycode,
    orderid = ppr_source.orderid,
    packagename = ppr_source.packagename,
    environment = ppr_source.environment,
    expirationintent = ppr_source.expirationintent,
    expiresdate = ppr_source.expiresdate,
    expirytime = ppr_source.expirytime,
    isinbillingretryperiod = ppr_source.isinbillingretryperiod,
    isinintroofferperiod = ppr_source.isinintroofferperiod,
    istrialperiod = ppr_source.istrialperiod,
    linkedpurchasetoken = ppr_source.linkedpurchasetoken,
    quantity = ppr_source.quantity,
    transactionid = ppr_source.transactionid,
    purchasestate = ppr_source.purchasestate,
    purchasetoken = ppr_source.purchasetoken,
    purchasetype = ppr_source.purchasetype,
    voidedreason = ppr_source.voidedreason,
    voidedsource = ppr_source.voidedsource,
    voidedtime = ppr_source.voidedtime,
    paymentstate = ppr_source.paymentstate,
    cancelreason = ppr_source.cancelreason,
    cancelsurveyresultcancelsurveyreason = ppr_source.cancelsurveyresultcancelsurveyreason,
    cancelsurveyresultuserinputcancelreason = ppr_source.cancelsurveyresultuserinputcancelreason,
    consumptionstate = ppr_source.consumptionstate,
    purchasestarttime = ppr_source.purchasestarttime,
    usercancellationtime = ppr_source.usercancellationtime,
    eventname = ppr_source.eventname,
    createdat = ppr_source.createdat,
    event_creation_timestamp = ppr_source.approximate_creation_date_time,
    updated_timestamp = CURRENT_TIMESTAMP(),
    s3_file_path = ppr_source.s3_file_path
WHEN NOT MATCHED THEN
INSERT (
    pk,
    sk,
    userid,
    bundleid,
    productid,
    producttype,
    status,
    developerpayload,
    autorenewing,
    calculatedexpiredate,
    cancellationdate,
    itemttl,
    cancellationreason,
    originalpurchasedate,
    originaltransactionid,
    vendor,
    countrycode,
    orderid,
    packagename,
    environment,
    expirationintent,
    expiresdate,
    expirytime,
    isinbillingretryperiod,
    isinintroofferperiod,
    istrialperiod,
    linkedpurchasetoken,
    quantity,
    transactionid,
    purchasestate,
    purchasetoken,
    purchasetype,
    voidedreason,
    voidedsource,
    voidedtime,
    paymentstate,
    cancelreason,
    cancelsurveyresultcancelsurveyreason,
    cancelsurveyresultuserinputcancelreason,
    consumptionstate,
    purchasestarttime,
    usercancellationtime,
    eventname,
    createdat,
    event_creation_timestamp,
    updated_timestamp,
    inserted_timestamp,
    s3_file_path
    )
VALUES (
    ppr_source.pk,
    ppr_source.sk,
    ppr_source.userid,
    ppr_source.bundleid,
    ppr_source.productid,
    ppr_source.producttype,
    ppr_source.status,
    ppr_source.developerpayload,
    ppr_source.autorenewing,
    ppr_source.calculatedexpiredate,
    ppr_source.cancellationdate,
    ppr_source.itemttl,
    ppr_source.cancellationreason,
    ppr_source.originalpurchasedate,
    ppr_source.originaltransactionid,
    ppr_source.vendor,
    ppr_source.countrycode,
    ppr_source.orderid,
    ppr_source.packagename,
    ppr_source.environment,
    ppr_source.expirationintent,
    ppr_source.expiresdate,
    ppr_source.expirytime,
    ppr_source.isinbillingretryperiod,
    ppr_source.isinintroofferperiod,
    ppr_source.istrialperiod,
    ppr_source.linkedpurchasetoken,
    ppr_source.quantity,
    ppr_source.transactionid,
    ppr_source.purchasestate,
    ppr_source.purchasetoken,
    ppr_source.purchasetype,
    ppr_source.voidedreason,
    ppr_source.voidedsource,
    ppr_source.voidedtime,
    ppr_source.paymentstate,
    ppr_source.cancelreason,
    ppr_source.cancelsurveyresultcancelsurveyreason,
    ppr_source.cancelsurveyresultuserinputcancelreason,
    ppr_source.consumptionstate,
    ppr_source.purchasestarttime,
    ppr_source.usercancellationtime,
    ppr_source.eventname,
    ppr_source.createdat,
    ppr_source.approximate_creation_date_time,
    CURRENT_TIMESTAMP(),
    CURRENT_TIMESTAMP(),
    ppr_source.s3_file_path
    );